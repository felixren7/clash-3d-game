<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Animal Royale - Autumn Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #2d1b0e; touch-action: none; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        
        /* ç§‹å­£æ°›å›´èƒŒæ™¯ */
        #game-container { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; 
            background: radial-gradient(circle at center, #8c5e2e 0%, #2d1b0e 100%); 
        }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        .pointer-events-auto { pointer-events: auto; }
        
        /* å¡ç‰Œæ ·å¼ - æš–è‰²è°ƒ */
        .card {
            transition: transform 0.15s cubic-bezier(0.175, 0.885, 0.32, 1.275), border-color 0.2s;
            background: linear-gradient(160deg, #744210 0%, #432611 100%); /* æœ¨è´¨/çš®é©è´¨æ„Ÿ */
            box-shadow: 0 4px 6px rgba(0,0,0,0.4);
            border-color: #b7791f;
        }
        .card.selected {
            transform: translateY(-30px) scale(1.15);
            border-color: #f6ad55;
            box-shadow: 0 0 20px rgba(246, 173, 85, 0.6);
            z-index: 50;
        }
        .card.disabled {
            filter: grayscale(100%);
            opacity: 0.6;
        }
        .role-icon {
            text-shadow: 0 2px 2px rgba(0,0,0,0.5);
        }

        /* è¡€æ¡ä¸åå­—å®¹å™¨ */
        .unit-label-container {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            transform: translate(-50%, -100%);
            pointer-events: none;
            z-index: 5;
            text-align: center;
            width: 100px; 
        }
        
        .unit-name {
            color: white;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000;
            margin-bottom: 2px;
            white-space: nowrap;
            opacity: 0.9;
        }

        .hp-bar {
            width: 36px;
            height: 5px;
            background: rgba(0,0,0,0.7);
            border-radius: 3px;
            padding: 1px;
            margin: 0 auto;
        }
        .hp-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.1s linear;
        }
        /* ç©å®¶ä¾ç„¶æ˜¯è“è‰²è°ƒä»¥åŒºåˆ†æ•Œæˆ‘ï¼Œä½†ç¨å¾®æš–ä¸€ç‚¹çš„è“ */
        .team-blue .hp-fill { background: linear-gradient(90deg, #4299e1, #63b3ed); }
        .team-red .hp-fill { background: linear-gradient(90deg, #f56565, #fc8181); }

        /* ä¼¤å®³æ•°å­— */
        .damage-text {
            position: absolute;
            font-weight: 900;
            font-size: 18px;
            -webkit-text-stroke: 1px #3e2723;
            pointer-events: none;
            animation: popAndFloat 0.8s ease-out forwards;
            z-index: 20;
            font-family: 'Impact', sans-serif;
        }
        @keyframes popAndFloat {
            0% { opacity: 0; transform: translateY(10px) scale(0.5); }
            20% { opacity: 1; transform: translateY(0) scale(1.2); }
            100% { opacity: 0; transform: translateY(-40px) scale(1); }
        }
        
        /* åŠ è½½é®ç½© - ç§‹æ—¥é£æ ¼ */
        #loading-screen {
            background: linear-gradient(135deg, #2d1b0e 0%, #000000 100%);
        }
        
        /* åœ£æ°´æ¡å‘å…‰ */
        .elixir-glow {
            box-shadow: 0 0 15px #ed8936;
        }
    </style>
</head>
<body>

    <!-- 3D ç”»å¸ƒ -->
    <div id="game-container"></div>

    <!-- HTML è¦†ç›–å±‚ (è¡€æ¡ã€åå­—ã€ä¼¤å®³) -->
    <div id="world-overlay" style="position: absolute; top:0; left:0; width:100%; height:100%; overflow:hidden; pointer-events:none; z-index: 5;"></div>

    <!-- UI å±‚ -->
    <div id="ui-layer" class="flex flex-col justify-between pb-safe">
        
        <!-- é¡¶éƒ¨æ  -->
        <div class="flex justify-between items-start p-2 w-full max-w-4xl mx-auto">
            <div class="bg-red-900/80 text-red-100 px-4 py-1 rounded-xl border-2 border-red-700 shadow-lg backdrop-blur-md">
                <span class="text-xs font-black tracking-wider text-red-200">å¯¹æ‰‹</span>
                <div class="text-xl font-bold leading-none drop-shadow-md" id="enemy-crowns">ğŸ‘‘ 0</div>
            </div>
            
            <!-- å€’è®¡æ—¶ï¼šæœ¨ç‰Œé£æ ¼ -->
            <div class="bg-yellow-900/90 text-amber-100 px-6 py-2 rounded-b-2xl border-b-4 border-yellow-950 shadow-xl flex flex-col items-center backdrop-blur-sm transform translate-y-[-5px]">
                <div id="game-timer" class="text-2xl font-black text-amber-400 tracking-widest font-mono drop-shadow-sm">03:00</div>
                <div id="ot-indicator" class="text-[9px] font-bold text-amber-200 uppercase tracking-widest hidden animate-pulse">å†³èƒœæ—¶åˆ»</div>
            </div>
            
            <div class="bg-blue-900/80 text-blue-100 px-4 py-1 rounded-xl border-2 border-blue-600 shadow-lg backdrop-blur-md">
                <span class="text-xs font-black tracking-wider text-blue-200">ä½ </span>
                <div class="text-xl font-bold leading-none drop-shadow-md" id="player-crowns">ğŸ‘‘ 0</div>
            </div>
        </div>

        <!-- åº•éƒ¨æ ï¼šå¡ç»„ä¸åœ£æ°´ -->
        <div class="w-full pb-2 px-2 pointer-events-auto bg-gradient-to-t from-[#1a0f00]/90 to-transparent pt-12">
            <!-- åœ£æ°´æ¡ -->
            <div class="w-full max-w-lg mx-auto mb-3 relative group">
                <div class="flex justify-between text-amber-100 text-xs font-bold px-2 mb-1 shadow-black drop-shadow-md uppercase tracking-wider">
                    <span>åœ£æ°´</span>
                    <span id="elixir-count" class="text-amber-300 text-lg">5</span>
                </div>
                <div class="h-5 w-full bg-[#3e2723] rounded-full border-2 border-[#5d4037] overflow-hidden relative shadow-inner">
                    <div id="elixir-fill" class="h-full bg-orange-600 w-0 relative shadow-[0_0_10px_rgba(237,137,54,0.8)]">
                        <div class="absolute top-0 left-0 w-full h-full bg-gradient-to-b from-orange-400 to-orange-700 opacity-90"></div>
                        <!-- å…‰æ³½ -->
                        <div class="absolute top-0 right-0 h-full w-2 bg-white/40 blur-[2px]"></div>
                    </div>
                    <!-- åˆ»åº¦çº¿ -->
                    <div class="absolute top-0 left-0 w-full h-full flex opacity-40">
                        <div class="flex-1 border-r border-[#8d6e63]"></div>
                        <div class="flex-1 border-r border-[#8d6e63]"></div>
                        <div class="flex-1 border-r border-[#8d6e63]"></div>
                        <div class="flex-1 border-r border-[#8d6e63]"></div>
                        <div class="flex-1 border-r border-[#8d6e63]"></div>
                        <div class="flex-1 border-r border-[#8d6e63]"></div>
                        <div class="flex-1 border-r border-[#8d6e63]"></div>
                        <div class="flex-1 border-r border-[#8d6e63]"></div>
                        <div class="flex-1 border-r border-[#8d6e63]"></div>
                        <div class="flex-1"></div>
                    </div>
                </div>
            </div>

            <!-- å¡ç‰ŒåŒºåŸŸ -->
            <div id="card-container" class="flex justify-center space-x-3 items-end h-32 max-w-3xl mx-auto perspective-1000 pb-2">
                <!-- JS ç”Ÿæˆå¡ç‰Œ -->
            </div>
            
            <div class="text-center text-amber-200/60 text-[10px] font-semibold mt-1 tracking-wide shadow-black drop-shadow-md">
                æ‹–æ‹½å¡ç‰Œè‡³æˆ˜åœº â€¢ ä¿æŠ¤ä½ çš„åŸå ¡
            </div>
        </div>
    </div>

    <!-- åŠ è½½å±å¹• -->
    <div id="loading-screen" class="fixed inset-0 z-50 flex flex-col items-center justify-center text-white pointer-events-auto">
        <div class="text-6xl mb-6 animate-bounce">ğŸ»</div>
        <h1 class="text-4xl font-black mb-8 tracking-tighter text-transparent bg-clip-text bg-gradient-to-b from-amber-300 to-orange-600 drop-shadow-lg">ANIMAL ROYALE</h1>
        <div class="w-64 h-3 bg-gray-800 rounded-full overflow-hidden mb-2 border border-gray-600">
            <div id="loading-bar" class="h-full bg-orange-500 w-0 transition-all duration-500 shadow-[0_0_10px_#ed8936]"></div>
        </div>
        <p class="text-amber-500/80 text-xs uppercase tracking-widest mt-2">æ­£åœ¨å¬å”¤åŠ¨ç‰©ä¼™ä¼´...</p>
        <button id="start-btn" class="mt-12 px-12 py-4 bg-gradient-to-b from-green-500 to-green-700 hover:from-green-400 hover:to-green-600 rounded-2xl font-black text-2xl shadow-xl transform hover:scale-105 transition hidden text-white border-b-4 border-green-900 active:border-b-0 active:translate-y-1">å¼€å§‹æˆ˜æ–—</button>
    </div>

    <!-- ç»“ç®—å±å¹• -->
    <div id="game-over-screen" class="fixed inset-0 z-50 flex flex-col items-center justify-center bg-black/90 hidden pointer-events-auto backdrop-blur-md">
        <h1 id="result-title" class="text-7xl font-black text-white mb-4 drop-shadow-2xl transform -rotate-3">èƒœåˆ©!</h1>
        <div class="flex gap-12 mb-10 text-center bg-[#3e2723] p-8 rounded-2xl border-4 border-[#5d4037] shadow-2xl">
            <div>
                <div class="text-blue-300 text-xs font-bold uppercase tracking-widest mb-2">æˆ‘æ–¹</div>
                <div id="result-crowns-blue" class="text-6xl font-bold text-white">3</div>
            </div>
            <div class="text-amber-700/50 text-5xl font-thin self-center">vs</div>
            <div>
                <div class="text-red-300 text-xs font-bold uppercase tracking-widest mb-2">æ•Œæ–¹</div>
                <div id="result-crowns-red" class="text-6xl font-bold text-white">0</div>
            </div>
        </div>
        <button onclick="location.reload()" class="px-10 py-4 bg-amber-600 hover:bg-amber-500 rounded-xl font-bold text-white shadow-lg border-b-4 border-amber-800 active:border-b-0 active:translate-y-1 text-xl">å†æ¥ä¸€å±€</button>
    </div>

    <script>
        /**
         * æ¸¸æˆé…ç½®ä¸æ•°æ®
         */
        const CONFIG = {
            ELIXIR_MAX: 10,
            ELIXIR_REGEN_RATE: 2.8, 
            GAME_DURATION: 180, 
            MAP_WIDTH: 18,
            MAP_HEIGHT: 32,
            BRIDGE_WIDTH: 4.0,
            TOWER_RANGE: 7.5,
            AGGRO_RANGE: 6,
        };

        // åŠ¨ç‰©å•ä½å®šä¹‰ (é«˜åº¦æ‹Ÿç‰©åŒ–)
        const UNIT_TYPES = {
            IGNIS: {
                id: 'ignis', name: 'å–·ç«é¾™', cost: 4, hp: 900, dmg: 140, speed: 2.5, range: 2.5, speedAtk: 1.4,
                color: 0xe53e3e, type: 'æˆ˜å£«', target: 'ground', icon: 'ğŸ‰',
                desc: 'å–·åç«ç„°çš„å·¨é¾™', model: 'dragon'
            },
            BOULDER: {
                id: 'boulder', name: 'å²©çŸ³å·¨åƒ', cost: 5, hp: 2100, dmg: 90, speed: 1.3, range: 1.0, speedAtk: 1.8,
                color: 0x718096, type: 'å¦å…‹', target: 'buildings', icon: 'ğŸ—¿',
                desc: 'åšç¡¬çš„å²©çŸ³æŠ¤ç›¾', model: 'golem'
            },
            VOLT: {
                id: 'volt', name: 'é›·ç”µé¼ ', cost: 3, hp: 450, dmg: 220, speed: 4.2, range: 1.5, speedAtk: 1.1,
                color: 0xf6e05e, type: 'åˆºå®¢', target: 'ground', icon: 'âš¡',
                desc: 'é€Ÿåº¦æå¿«ï¼Œé«˜çˆ†å‘', model: 'mouse'
            },
            AQUANAUT: {
                id: 'aquanaut', name: 'é‡ç‚®é¾Ÿ', cost: 4, hp: 700, dmg: 100, speed: 1.8, range: 5.5, speedAtk: 1.3,
                color: 0x4299e1, type: 'å°„æ‰‹', target: 'all', icon: 'ğŸ¢',
                desc: 'è¿œç¨‹æ°´ç‚®æ‰“å‡»', model: 'turtle'
            },
            SPECTER: {
                id: 'specter', name: 'æš—å¤œè ', cost: 3, hp: 280, dmg: 140, speed: 3.5, range: 2.0, speedAtk: 0.9,
                color: 0x805ad5, type: 'é£è¡Œ', target: 'ground', flying: true, icon: 'ğŸ¦‡',
                desc: 'ç©ºä¸­å•ä½ï¼Œé«˜ä¼¤å®³', model: 'bat'
            },
            TITAN: {
                id: 'titan', name: 'æ£•ç†Šå‹‡å£«', cost: 6, hp: 2600, dmg: 180, speed: 1.4, range: 1.2, speedAtk: 1.6,
                color: 0x5D4037, type: 'å¦å…‹', target: 'buildings', icon: 'ğŸ»',
                desc: 'åªä¼šæ”»å‡»å»ºç­‘', model: 'bear'
            },
            FAE: {
                id: 'fae', name: 'é£ä¹‹è¶', cost: 2, hp: 180, dmg: 65, speed: 4.0, range: 3.5, speedAtk: 0.7,
                color: 0xf687b3, type: 'é£è¡Œ', target: 'all', flying: true, icon: 'ğŸ¦‹',
                desc: 'ä½è´¹ç©ºä¸­æ”¯æ´', model: 'butterfly'
            },
            GLACIER: {
                id: 'glacier', name: 'å†°éœœä¼é¹…', cost: 5, hp: 850, dmg: 115, speed: 1.9, range: 5.0, speedAtk: 1.5,
                color: 0x81e6d9, type: 'æ³•å¸ˆ', target: 'all', icon: 'ğŸ§',
                desc: 'é€ æˆèŒƒå›´å†°å†»ä¼¤å®³', model: 'penguin'
            }
        };

        const CARD_DECK = Object.keys(UNIT_TYPES);

        // æ¸¸æˆçŠ¶æ€
        let scene, camera, renderer, raycaster;
        let clock = new THREE.Clock();
        let mouse = new THREE.Vector2();
        
        let gameActive = false;
        let gameTime = CONFIG.GAME_DURATION;
        let elixir = 5.0; 
        let entities = []; 
        let projectiles = [];
        let particles = [];
        
        let playerHand = [];
        let nextCard = null;
        let selectedCardIdx = -1;
        let teamBlueCrowns = 0;
        let teamRedCrowns = 0;

        const materials = {};
        const geometries = {};
        let textures = {};

        const elElixirFill = document.getElementById('elixir-fill');
        const elElixirCount = document.getElementById('elixir-count');
        const elTimer = document.getElementById('game-timer');
        const elContainer = document.getElementById('game-container');
        const elWorldOverlay = document.getElementById('world-overlay');

        /**
         * çº¹ç†ç”Ÿæˆ (ç§‹å­£é£æ ¼)
         */
        function generateTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            if (type === 'grass') {
                // æš–è‰²è°ƒç§‹æ—¥è‰åœ°
                ctx.fillStyle = '#5D4037'; // åœŸå£¤åº•è‰²
                ctx.fillRect(0,0,512,512);
                for(let i=0; i<60000; i++) {
                    // é‡‘é»„ã€æ©™è‰²ã€æ¯è‰ç»¿æ··åˆ
                    const colors = ['#d97706', '#b45309', '#654321', '#4d7c0f']; 
                    ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.arc(Math.random()*512, Math.random()*512, Math.random()*2.5, 0, Math.PI*2);
                    ctx.fill();
                }
            } else if (type === 'water') {
                ctx.fillStyle = '#2563eb';
                ctx.fillRect(0,0,512,512);
                ctx.strokeStyle = '#60a5fa';
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.3;
                for(let i=0; i<60; i++) {
                    ctx.beginPath();
                    let x = Math.random() * 512;
                    let y = Math.random() * 512;
                    ctx.moveTo(x, y);
                    ctx.bezierCurveTo(x+30, y-15, x+50, y+15, x+80, y);
                    ctx.stroke();
                }
            } else if (type === 'bridge') {
                ctx.fillStyle = '#4a3728'; // æ·±æœ¨è‰²
                ctx.fillRect(0,0,512,512);
                ctx.fillStyle = '#3e2c22';
                for(let i=0; i<8; i++) {
                    ctx.fillRect(0, i*64 + 4, 512, 56); // æœ¨æ¿ç¼éš™
                }
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        /**
         * åˆå§‹åŒ–
         */
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2d1b0e);
            scene.fog = new THREE.FogExp2(0x2d1b0e, 0.02); // æµ“é›¾å¢åŠ ç§‹æ—¥æ°›å›´

            camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 42, 30); 
            camera.lookAt(0, 0, -4); 

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            elContainer.appendChild(renderer.domElement);

            // æš–è‰²ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffecd2, 0.5); // æš–ç™½å…‰
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffaa00, 1.2); // å¤•é˜³é‡‘å…‰
            sunLight.position.set(12, 30, 15);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.bias = -0.001;
            scene.add(sunLight);

            raycaster = new THREE.Raycaster();
            
            window.addEventListener('resize', onWindowResize, false);
            elContainer.addEventListener('pointerdown', onPointerDown);

            textures.grass = generateTexture('grass');
            textures.water = generateTexture('water');
            textures.bridge = generateTexture('bridge');
            
            createAssets();
            createMap();
            setupUI();

            document.getElementById('loading-bar').style.width = '100%';
            setTimeout(() => {
                document.getElementById('start-btn').classList.remove('hidden');
            }, 600);
        }

        function createAssets() {
            materials.ground = new THREE.MeshStandardMaterial({ map: textures.grass, roughness: 1.0 });
            materials.river = new THREE.MeshStandardMaterial({ map: textures.water, transparent: true, opacity: 0.85, roughness: 0.0, metalness: 0.4 });
            materials.bridge = new THREE.MeshStandardMaterial({ map: textures.bridge, roughness: 0.9 });
            materials.highlightValid = new THREE.MeshBasicMaterial({ color: 0x48bb78, transparent: true, opacity: 0.4, side: THREE.DoubleSide });
        }

        /**
         * é«˜çº§åŠ¨ç‰©æ‹Ÿç‰©å»ºæ¨¡ (Lego-style Animal Sculpting)
         */
        function createUnitModel(typeKey, team) {
            const unitData = UNIT_TYPES[typeKey];
            const group = new THREE.Group();
            
            // å›¢é˜Ÿè‰²
            const teamColor = team === 'blue' ? 0x3182ce : 0xe53e3e;
            const mainColor = unitData.color;

            // æè´¨
            const matMain = new THREE.MeshStandardMaterial({ color: mainColor });
            const matTeam = new THREE.MeshStandardMaterial({ color: teamColor });
            const matWhite = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const matBlack = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const matDark = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const matBeak = new THREE.MeshStandardMaterial({ color: 0xffa500 }); // æ©™è‰²å–™/çˆª

            if (unitData.model === 'bear') { // æ£•ç†Š (Titan)
                const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.4, 0.8), matMain);
                body.position.y = 1.2;
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.8, 0.8), matMain);
                head.position.y = 2.3; head.position.z = 0.2;
                const snout = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.3), new THREE.MeshStandardMaterial({color: 0xd2b48c}));
                snout.position.set(0, 2.2, 0.7);
                const earL = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 0.1), matMain); earL.position.set(-0.35, 2.7, 0.2);
                const earR = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 0.1), matMain); earR.position.set(0.35, 2.7, 0.2);
                // å›´å·¾(å›¢é˜Ÿè‰²)
                const scarf = new THREE.Mesh(new THREE.BoxGeometry(1.3, 0.2, 0.9), matTeam);
                scarf.position.y = 1.95;
                group.add(body, head, snout, earL, earR, scarf);

            } else if (unitData.model === 'penguin') { // ä¼é¹… (Glacier)
                // ä¿®å¤: CapsuleGeometryä¸æ˜¯å†…ç½®çš„ï¼Œæ›¿æ¢ä¸ºCylinder + Sphere
                const bodyHeight = 0.8 * 2;
                const bodyRadius = 0.5;
                
                // èº«ä½“ (åœ†æŸ±ä½“)
                const body = new THREE.Mesh(new THREE.CylinderGeometry(bodyRadius, bodyRadius * 0.8, bodyHeight, 10), new THREE.MeshStandardMaterial({color: 0x2c3e50}));
                body.position.y = bodyHeight / 2;
                
                // è…¹éƒ¨ (ç™½è‰²éƒ¨åˆ†, ç¨æ‰çš„åœ†æŸ±ä½“)
                const belly = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.35, bodyHeight * 0.8, 10), matWhite);
                belly.position.set(0, bodyHeight / 2, 0.15);

                // å¤´éƒ¨ (å°çƒ)
                const head = new THREE.Mesh(new THREE.SphereGeometry(bodyRadius * 0.7, 10, 8), new THREE.MeshStandardMaterial({color: 0x2c3e50}));
                head.position.y = bodyHeight + 0.1;
                
                const beak = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.3, 8), matBeak);
                beak.rotation.x = Math.PI/2; beak.position.set(0, bodyHeight + 0.1, 0.5);
                
                // æ³•æ–
                const staff = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.6), new THREE.MeshStandardMaterial({color: 0x5D4037}));
                staff.position.set(0.6, 1.0, 0.2); staff.rotation.z = -0.2;
                const gem = new THREE.Mesh(new THREE.DodecahedronGeometry(0.2), new THREE.MeshStandardMaterial({color: 0x00ffff, emissive: 0x00aaaa}));
                gem.position.set(0.75, 1.8, 0.2);
                group.add(body, belly, head, beak, staff, gem);

            } else if (unitData.model === 'mouse') { // é›·ç”µé¼  (Volt)
                const body = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 12), matMain);
                body.position.y = 0.5;
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.4, 12, 12), matMain);
                head.position.set(0, 0.9, 0.1);
                const earL = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.6, 8), matMain); earL.position.set(-0.3, 1.3, 0); earL.rotation.z = 0.4;
                const earR = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.6, 8), matMain); earR.position.set(0.3, 1.3, 0); earR.rotation.z = -0.4;
                // é—ªç”µå°¾å·´
                const tailGeo = new THREE.BufferGeometry();
                const vertices = new Float32Array([0,0,0, 0.2,0.4,0, -0.1,0.7,0, 0.3,1.1,0]);
                tailGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                // è¿™é‡Œç”¨ç®€å•çš„Boxæ¨¡æ‹Ÿé—ªç”µå½¢çŠ¶
                const tail1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.5, 0.05), matMain); tail1.position.set(0, 0.7, -0.4); tail1.rotation.z = 0.5; tail1.rotation.x = 0.5;
                const tail2 = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.05), matMain); tail2.position.set(0.2, 1.1, -0.6); tail2.rotation.z = -0.3; tail2.rotation.x = 0.5;
                group.add(body, head, earL, earR, tail1, tail2);

            } else if (unitData.model === 'dragon') { // å–·ç«é¾™
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.9, 0.7), matMain);
                body.position.y = 0.8;
                const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 0.5), matMain);
                neck.position.set(0, 1.4, 0.3); neck.rotation.x = -0.3;
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.6), matMain);
                head.position.set(0, 1.7, 0.5);
                // ç¿…è†€ (å†…éƒ¨æ˜¯å›¢é˜Ÿè‰²)
                const wingGeo = new THREE.BoxGeometry(1.2, 0.1, 0.8);
                const wL = new THREE.Mesh(wingGeo, matTeam); wL.position.set(-0.7, 1.2, 0); wL.rotation.z = 0.4;
                const wR = new THREE.Mesh(wingGeo, matTeam); wR.position.set(0.7, 1.2, 0); wR.rotation.z = -0.4;
                const tail = new THREE.Mesh(new THREE.ConeGeometry(0.15, 1.0), matMain);
                tail.position.set(0, 0.4, -0.6); tail.rotation.x = -1.2;
                group.add(body, neck, head, wL, wR, tail);

            } else if (unitData.model === 'turtle') { // é‡ç‚®é¾Ÿ
                const shell = new THREE.Mesh(new THREE.SphereGeometry(0.7, 12, 10, 0, Math.PI*2, 0, Math.PI/2), new THREE.MeshStandardMaterial({color: 0x2f855a})); // ç»¿å£³
                shell.rotation.x = Math.PI; 
                shell.position.y = 0.8;
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.4), matMain);
                body.position.y = 0.3;
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.5), matMain);
                head.position.set(0, 0.5, 0.7);
                // æ°´ç‚®ç®¡
                const cannonL = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.8), matDark);
                cannonL.rotation.x = Math.PI/2; cannonL.position.set(-0.4, 0.9, 0.3);
                const cannonR = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.8), matDark);
                cannonR.rotation.x = Math.PI/2; cannonR.position.set(0.4, 0.9, 0.3);
                group.add(shell, body, head, cannonL, cannonR);

            } else if (unitData.model === 'golem') { // å²©çŸ³å·¨åƒ
                const matRock = new THREE.MeshStandardMaterial({ color: 0x7f8c8d, roughness: 0.9 });
                // èº«ä½“ç”±å¤šä¸ªä¸è§„åˆ™å—ç»„æˆ
                const torso = new THREE.Mesh(new THREE.DodecahedronGeometry(0.7), matRock); torso.position.y = 1.0;
                const shoulderL = new THREE.Mesh(new THREE.DodecahedronGeometry(0.4), matRock); shoulderL.position.set(-0.7, 1.3, 0);
                const shoulderR = new THREE.Mesh(new THREE.DodecahedronGeometry(0.4), matRock); shoulderR.position.set(0.7, 1.3, 0);
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 0.5), matRock); head.position.y = 1.7;
                // æ ¸å¿ƒå‘å…‰
                const core = new THREE.Mesh(new THREE.PlaneGeometry(0.3, 0.3), new THREE.MeshBasicMaterial({color: teamColor}));
                core.position.set(0, 1.0, 0.65);
                group.add(torso, shoulderL, shoulderR, head, core);

            } else if (unitData.model === 'butterfly') { // è´è¶ (Fae)
                // ä¿®å¤: CapsuleGeometryä¸æ˜¯å†…ç½®çš„ï¼Œæ›¿æ¢ä¸ºCylinder
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8), matDark);
                body.rotation.x = Math.PI/2;
                
                // ç¿…è†€ - å››ç‰‡
                const wingMat = new THREE.MeshStandardMaterial({color: mainColor, transparent: true, opacity: 0.8, side: THREE.DoubleSide});
                const wingTL = new THREE.Mesh(new THREE.CircleGeometry(0.4, 16, 0, 2.5), wingMat); wingTL.position.set(-0.1, 0, 0.1); wingTL.rotation.set(0, -0.2, 0.5);
                const wingTR = new THREE.Mesh(new THREE.CircleGeometry(0.4, 16, 0, 2.5), wingMat); wingTR.position.set(0.1, 0, 0.1); wingTR.rotation.set(0, 0.2, -0.5); wingTR.scale.x = -1;
                const wingBL = new THREE.Mesh(new THREE.CircleGeometry(0.25, 16), wingMat); wingBL.position.set(-0.1, 0, -0.2); wingBL.rotation.set(0, -0.2, 0.2);
                const wingBR = new THREE.Mesh(new THREE.CircleGeometry(0.25, 16), wingMat); wingBR.position.set(0.1, 0, -0.2); wingBR.rotation.set(0, 0.2, -0.2); wingBR.scale.x = -1;
                group.add(body, wingTL, wingTR, wingBL, wingBR);

            } else if (unitData.model === 'bat') { // è™è  (Specter)
                const body = new THREE.Mesh(new THREE.SphereGeometry(0.25), matMain);
                // å¤§è€³æœµ
                const earL = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.3), matMain); earL.position.set(-0.1, 0.25, 0); earL.rotation.z = 0.3;
                const earR = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.3), matMain); earR.position.set(0.1, 0.25, 0); earR.rotation.z = -0.3;
                // è™è ç¿…è†€
                const wingShape = new THREE.Shape();
                wingShape.moveTo(0,0); wingShape.lineTo(0.8, 0.4); wingShape.lineTo(0.6, -0.2); wingShape.lineTo(0.3, -0.1); wingShape.lineTo(0, -0.3);
                const wingGeo = new THREE.ShapeGeometry(wingShape);
                const wingMat = new THREE.MeshStandardMaterial({color: 0x553c9a, side: THREE.DoubleSide});
                const wL = new THREE.Mesh(wingGeo, wingMat); wL.position.x = -0.2; wL.scale.x = -1;
                const wR = new THREE.Mesh(wingGeo, wingMat); wR.position.x = 0.2;
                group.add(body, earL, earR, wL, wR);
            }

            // å½±å­
            const shadow = new THREE.Mesh(new THREE.CircleGeometry(0.6, 16), new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 }));
            shadow.rotation.x = -Math.PI / 2;
            shadow.position.y = 0.05;
            group.add(shadow);

            // å›¢é˜Ÿå…‰ç¯ (ç¨å¾®å¼±ä¸€ç‚¹)
            const ring = new THREE.Mesh(new THREE.RingGeometry(0.7, 0.8, 32), new THREE.MeshBasicMaterial({ color: teamColor, transparent: true, opacity: 0.4 }));
            ring.rotation.x = -Math.PI/2;
            ring.position.y = 0.06;
            group.add(ring);

            group.traverse(o => {
                if(o.isMesh) {
                    o.castShadow = true;
                    o.receiveShadow = true;
                }
            });

            return group;
        }

        function createMap() {
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(24, 40), materials.ground);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.name = "ground";
            scene.add(ground);

            const river = new THREE.Mesh(new THREE.PlaneGeometry(24, 3.5), materials.river);
            river.rotation.x = -Math.PI / 2;
            river.position.y = 0.1;
            river.name = "river";
            scene.add(river);

            const createBridge = (x) => {
                const bridge = new THREE.Mesh(new THREE.BoxGeometry(CONFIG.BRIDGE_WIDTH, 0.3, 5), materials.bridge);
                bridge.position.set(x, 0.15, 0);
                bridge.receiveShadow = true;
                scene.add(bridge);
                
                // æ¡¥æ æ†
                const postGeo = new THREE.BoxGeometry(0.2, 0.6, 0.2);
                const railMat = new THREE.MeshStandardMaterial({color: 0x3e2c22});
                for(let z=-2; z<=2; z+=1.5) {
                    const p1 = new THREE.Mesh(postGeo, railMat); p1.position.set(x - CONFIG.BRIDGE_WIDTH/2 + 0.2, 0.4, z);
                    const p2 = new THREE.Mesh(postGeo, railMat); p2.position.set(x + CONFIG.BRIDGE_WIDTH/2 - 0.2, 0.4, z);
                    scene.add(p1, p2);
                }
            };
            createBridge(-5.5);
            createBridge(5.5);

            // ç¯å¢ƒï¼šç§‹å­£æ ‘æœ¨
            const spawnTree = (x, z) => {
                const tree = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 1.5), new THREE.MeshStandardMaterial({color: 0x4a3728}));
                trunk.position.y = 0.75;
                // æ ‘å¶ï¼šæ©™è‰²/çº¢è‰²/é»„è‰²
                const leafColor = [0xd97706, 0xc05621, 0xb7791f][Math.floor(Math.random()*3)];
                const leaves = new THREE.Mesh(new THREE.DodecahedronGeometry(1.2), new THREE.MeshStandardMaterial({color: leafColor}));
                leaves.position.y = 2.2;
                leaves.rotation.y = Math.random();
                tree.add(trunk, leaves);
                tree.position.set(x, 0, z);
                tree.traverse(o=>o.castShadow=true);
                scene.add(tree);
            };
            // å·¦ä¾§æ£®æ—
            spawnTree(-10, 5); spawnTree(-11, 12); spawnTree(-9, -8); spawnTree(-10, -2);
            // å³ä¾§æ£®æ—
            spawnTree(10, 2); spawnTree(11, -5); spawnTree(9, 8); spawnTree(10, 14);

            // å¡” (å›½ç‹å¡”ä¸å…¬ä¸»å¡”)
            spawnTower('blue', 'king', 0, 13, 4000, 120);
            spawnTower('blue', 'princess', -5.5, 9, 2500, 90);
            spawnTower('blue', 'princess', 5.5, 9, 2500, 90);
            spawnTower('red', 'king', 0, -13, 4000, 120);
            spawnTower('red', 'princess', -5.5, -9, 2500, 90);
            spawnTower('red', 'princess', 5.5, -9, 2500, 90);
        }

        /**
         * æ¸¸æˆé€»è¾‘ç±»
         */
        class Entity {
            constructor(team, x, z, hp, name) {
                this.team = team; 
                this.hp = hp;
                this.maxHp = hp;
                this.isDead = false;
                this.name = name;
                this.position = new THREE.Vector3(x, 0, z);
                
                // åˆ›å»º HTML UI (åå­— + è¡€æ¡)
                this.uiContainer = document.createElement('div');
                this.uiContainer.className = 'unit-label-container';
                
                // åå­—å…ƒç´ 
                const nameEl = document.createElement('div');
                nameEl.className = 'unit-name';
                nameEl.innerText = name || '';
                
                // è¡€æ¡å®¹å™¨
                const barContainer = document.createElement('div');
                barContainer.className = `hp-bar team-${team}`;
                barContainer.innerHTML = '<div class="hp-fill" style="width: 100%"></div>';
                
                this.uiContainer.appendChild(nameEl);
                this.uiContainer.appendChild(barContainer);
                
                elWorldOverlay.appendChild(this.uiContainer);
                this.hpBarFill = barContainer.querySelector('.hp-fill');
            }

            takeDamage(amount) {
                if (this.isDead) return;
                this.hp -= amount;
                
                // é£˜å­—
                const isCrit = Math.random() > 0.85;
                const finalDmg = isCrit ? amount * 1.5 : amount;
                showFloatingText(Math.floor(finalDmg), this.position.clone(), this.team === 'blue' ? 'red' : 'white', isCrit);

                // æ›´æ–°UI
                const pct = Math.max(0, (this.hp / this.maxHp) * 100);
                this.hpBarFill.style.width = `${pct}%`;
                
                // å—å‡»é—ªå…‰
                if(this.mesh) {
                    this.mesh.traverse(c => {
                        if(c.isMesh && c.material.emissive) {
                            const old = c.material.emissive.getHex();
                            c.material.emissive.setHex(0xff0000);
                            setTimeout(() => { if(c) c.material.emissive.setHex(old); }, 100);
                        }
                    });
                }

                if (this.hp <= 0) this.die();
            }

            die() {
                this.isDead = true;
                if(this.mesh) scene.remove(this.mesh);
                elWorldOverlay.removeChild(this.uiContainer);
                spawnParticles(this.position, 15, this.team === 'blue' ? 0x4299e1 : 0xf56565);
                
                if (this instanceof Tower) {
                    if (this.type === 'king') endGame(this.team === 'red' ? 'win' : 'lose');
                    else {
                        if (this.team === 'red') {
                            teamBlueCrowns++;
                            document.getElementById('player-crowns').innerText = `ğŸ‘‘ ${teamBlueCrowns}`;
                        } else {
                            teamRedCrowns++;
                            document.getElementById('enemy-crowns').innerText = `ğŸ‘‘ ${teamRedCrowns}`;
                        }
                    }
                }
            }

            updateUI() {
                const vector = this.position.clone();
                // é«˜åº¦åç§»
                vector.y += (this instanceof Tower) ? (this.type==='king'?5.5:4.5) : (this instanceof Unit && this.stats.flying ? 3.5 : 2.2);
                vector.project(camera);

                const x = (vector.x * .5 + .5) * window.innerWidth;
                const y = (-(vector.y * .5) + .5) * window.innerHeight;

                this.uiContainer.style.left = `${x}px`;
                this.uiContainer.style.top = `${y}px`;
                
                // ç®€å•çš„é®æŒ¡éšè—
                if (vector.z > 1 || vector.z < -1 || Math.abs(vector.x) > 1.2) {
                    this.uiContainer.style.display = 'none';
                } else {
                    this.uiContainer.style.display = 'flex';
                }
            }
        }

        class Unit extends Entity {
            constructor(team, typeKey, x, z) {
                const stats = UNIT_TYPES[typeKey];
                super(team, x, z, stats.hp, stats.name);
                this.stats = stats;
                
                this.mesh = createUnitModel(typeKey, team);
                this.mesh.position.copy(this.position);
                if (stats.flying) {
                    this.mesh.position.y = 2.5;
                    this.position.y = 2.5;
                }
                
                // åˆå§‹æœå‘
                const lookZ = team==='blue' ? -15 : 15;
                this.mesh.lookAt(this.position.x, this.position.y, lookZ);

                scene.add(this.mesh);

                this.state = 'idle'; 
                this.target = null;
                this.attackTimer = 0;
            }

            update(dt) {
                if (this.isDead) return;
                this.updateUI();

                if (this.attackTimer > 0) this.attackTimer -= dt;

                this.findTarget();

                if (this.target) {
                    const dist = this.position.distanceTo(this.target.position);
                    if (dist <= (this.stats.range + 0.5)) {
                        if (this.attackTimer <= 0) this.attack();
                    } else {
                        this.moveTowards(this.target.position, dt);
                    }
                } else {
                    this.advanceLane(dt);
                }
            }

            findTarget() {
                if (this.target && this.target.isDead) this.target = null;

                let closest = null;
                let minDist = this.stats.target === 'buildings' ? Infinity : CONFIG.AGGRO_RANGE; 

                for (let e of entities) {
                    if (e.team === this.team || e.isDead) continue;
                    if (this.stats.target === 'buildings' && !(e instanceof Tower)) continue;
                    if (this.stats.target === 'ground' && e instanceof Unit && e.stats.flying) continue;

                    const d = this.position.distanceTo(e.position);
                    if (d < minDist) {
                        minDist = d;
                        closest = e;
                    }
                }
                
                // å¦‚æœèŒƒå›´å†…æ²¡æœ‰å…µï¼Œæ‰¾å¡”
                if (!closest) {
                    minDist = Infinity;
                    for (let e of entities) {
                        if (e instanceof Tower && e.team !== this.team && !e.isDead) {
                            const d = this.position.distanceTo(e.position);
                            if (d < minDist) {
                                minDist = d;
                                closest = e;
                            }
                        }
                    }
                }
                this.target = closest;
            }

            moveTowards(targetPos, dt) {
                const targetVec = targetPos.clone();
                targetVec.y = this.stats.flying ? 2.5 : 0;

                const dir = new THREE.Vector3().subVectors(targetVec, this.position).normalize();
                this.position.add(dir.multiplyScalar(this.stats.speed * dt));
                this.mesh.position.copy(this.position);
                
                // å¹³æ»‘è½¬å‘
                const lookTarget = targetVec.clone();
                lookTarget.y = this.mesh.position.y;
                this.mesh.lookAt(lookTarget);
                
                // èµ°è·¯åŠ¨ç”» (Bounce)
                if (!this.stats.flying) {
                    this.mesh.position.y = Math.abs(Math.sin(clock.elapsedTime * 10)) * 0.1; 
                } else {
                    // é£è¡Œæµ®åŠ¨
                    this.mesh.position.y = 2.5 + Math.sin(clock.elapsedTime * 3) * 0.2;
                }
            }

            advanceLane(dt) {
                const isLeft = this.position.x < 0;
                const targetZ = this.team === 'blue' ? -12 : 12; 
                // è¿‡æ²³ç‚¹
                let waypoint = new THREE.Vector3(isLeft ? -5.5 : 5.5, 0, targetZ);
                
                // å¦‚æœè¿˜æ²¡è¿‡æ²³ï¼Œå…ˆå»æ¡¥å¤´
                const pastRiver = this.team === 'blue' ? (this.position.z < -2) : (this.position.z > 2);
                if (!pastRiver) {
                    waypoint = new THREE.Vector3(isLeft ? -5.5 : 5.5, 0, this.team === 'blue' ? -0.5 : 0.5);
                }

                this.moveTowards(waypoint, dt);
            }

            attack() {
                this.attackTimer = 1.0 / this.stats.speedAtk;
                
                // æ”»å‡»å‰æ‘‡åŠ¨ä½œ
                this.mesh.translateZ(0.3);
                setTimeout(() => { if(!this.isDead) this.mesh.translateZ(-0.3); }, 100);

                if (this.stats.type === 'å°„æ‰‹' || this.stats.type === 'æ³•å¸ˆ' || this.stats.type === 'é£è¡Œ') {
                    spawnProjectile(this, this.target);
                } else {
                    // è¿‘æˆ˜
                    this.target.takeDamage(this.stats.dmg);
                    spawnParticles(this.target.position.clone().add(new THREE.Vector3(0,1,0)), 3, 0xffffff);
                }
            }
        }

        class Tower extends Entity {
            constructor(team, type, x, z, hp, dmg) {
                super(team, x, z, hp, type === 'king' ? 'å›½ç‹å¡”' : 'å…¬ä¸»å¡”');
                this.type = type; 
                this.dmg = dmg;
                this.range = CONFIG.TOWER_RANGE + (type === 'king' ? 1 : 0);
                this.attackTimer = 0;
                this.speedAtk = 0.8; 
                this.active = type === 'princess'; 

                // åŸå ¡æ¨¡å‹
                this.mesh = new THREE.Group();
                this.mesh.position.set(x, 0, z);
                
                const teamColor = team === 'blue' ? 0x3182ce : 0xe53e3e;
                const matStone = new THREE.MeshStandardMaterial({ color: 0x718096 }); // ç°çŸ³
                const matWood = new THREE.MeshStandardMaterial({ color: 0x5D4037 }); // æ·±æœ¨
                const matTeam = new THREE.MeshStandardMaterial({ color: teamColor });
                
                const baseW = type==='king' ? 3 : 2.2;
                const baseH = 2.5;
                
                // å¡”åŸº
                const base = new THREE.Mesh(new THREE.BoxGeometry(baseW, baseH, baseW), matStone);
                base.position.y = baseH/2;
                
                // å¡”æ¥¼
                const turretH = 1.5;
                const turret = new THREE.Mesh(new THREE.CylinderGeometry(baseW*0.4, baseW*0.4, turretH, 8), matStone);
                turret.position.y = baseH + turretH/2;
                
                // å±‹é¡¶
                const roof = new THREE.Mesh(new THREE.ConeGeometry(baseW*0.6, 1.5, 4), matTeam);
                roof.position.y = baseH + turretH + 0.75;
                roof.rotation.y = Math.PI/4;

                // è£…é¥°æ——å¸œ
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1), matWood);
                pole.position.set(0, baseH + turretH + 1.5, 0);
                const flag = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.4, 0.05), matTeam);
                flag.position.set(0.3, baseH + turretH + 1.8, 0);

                this.mesh.add(base, turret, roof, pole, flag);
                this.mesh.traverse(o => {o.castShadow=true; o.receiveShadow=true;});
                
                scene.add(this.mesh);
            }

            update(dt) {
                if (this.isDead) return;
                this.updateUI();

                if (this.type === 'king' && !this.active) {
                    if (this.hp < this.maxHp) this.active = true;
                }

                if (!this.active) return;
                if (this.attackTimer > 0) this.attackTimer -= dt;

                let target = null;
                let minDist = this.range;

                for (let e of entities) {
                    if (e.team !== this.team && !e.isDead && e instanceof Unit) {
                        const d = this.position.distanceTo(e.position);
                        if (d < minDist) {
                            minDist = d;
                            target = e;
                        }
                    }
                }

                if (target && this.attackTimer <= 0) {
                    this.attackTimer = this.speedAtk;
                    spawnProjectile(this, target);
                }
            }
        }

        function spawnProjectile(owner, target) {
            const pGeo = new THREE.SphereGeometry(0.25, 8, 8);
            // æŠ•å°„ç‰©é¢œè‰²ï¼šå†°éœœæ˜¯é’è‰²ï¼Œç«é¾™æ˜¯çº¢è‰²
            let pColor = owner.team === 'blue' ? 0x63b3ed : 0xfc8181;
            if (owner instanceof Unit && owner.stats.id === 'glacier') pColor = 0x81e6d9;
            if (owner instanceof Unit && owner.stats.id === 'ignis') pColor = 0xff4500;

            const pMat = new THREE.MeshBasicMaterial({ color: pColor });
            
            const p = {
                mesh: new THREE.Mesh(pGeo, pMat),
                pos: owner.position.clone().add(new THREE.Vector3(0, (owner instanceof Tower ? 4 : 1.5), 0)),
                target: target,
                speed: 12,
                dmg: owner instanceof Unit ? owner.stats.dmg : owner.dmg,
                active: true,
                update: function(dt) {
                    if (!this.active) return;
                    if (this.target.isDead) { this.destroy(); return; }
                    
                    const tPos = this.target.position.clone().add(new THREE.Vector3(0,1,0));
                    const dir = new THREE.Vector3().subVectors(tPos, this.pos).normalize();
                    const move = dir.multiplyScalar(this.speed * dt);
                    
                    if (this.pos.distanceTo(tPos) < 0.5 || move.length() >= this.pos.distanceTo(tPos)) {
                        this.target.takeDamage(this.dmg);
                        this.destroy();
                    } else {
                        this.pos.add(move);
                        this.mesh.position.copy(this.pos);
                    }
                },
                destroy: function() {
                    this.active = false;
                    scene.remove(this.mesh);
                }
            };
            p.mesh.position.copy(p.pos);
            scene.add(p.mesh);
            projectiles.push(p);
        }

        function spawnParticles(pos, count, color) {
            const mat = new THREE.MeshBasicMaterial({ color: color });
            const geo = new THREE.BoxGeometry(0.15, 0.15, 0.15);
            
            for(let i=0; i<count; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                mesh.position.x += (Math.random()-0.5);
                mesh.position.y += (Math.random()-0.5);
                mesh.position.z += (Math.random()-0.5);
                
                const vel = new THREE.Vector3((Math.random()-0.5)*4, Math.random()*4, (Math.random()-0.5)*4);
                scene.add(mesh);
                particles.push({ mesh, vel, life: 0.6 });
            }
        }

        function showFloatingText(text, pos, colorClass, isCrit) {
            const el = document.createElement('div');
            el.className = 'damage-text';
            el.innerText = text + (isCrit ? "!" : "");
            el.style.color = colorClass === 'red' ? '#ff6b6b' : '#ffffff';
            if (isCrit) {
                el.style.fontSize = '26px';
                el.style.color = '#f6e05e';
                el.style.zIndex = '25';
            }
            elWorldOverlay.appendChild(el);

            pos.y += 2.5;
            pos.project(camera);
            const x = (pos.x * .5 + .5) * window.innerWidth;
            const y = (-(pos.y * .5) + .5) * window.innerHeight;
            
            el.style.left = `${x}px`;
            el.style.top = `${y}px`;

            setTimeout(() => el.remove(), 800);
        }

        function spawnTower(team, type, x, z, hp, dmg) {
            entities.push(new Tower(team, type, x, z, hp, dmg));
        }
        function spawnUnit(team, typeKey, x, z) {
            entities.push(new Unit(team, typeKey, x, z));
        }

        /**
         * UI é€»è¾‘
         */
        function setupUI() {
            document.getElementById('start-btn').onclick = startGame;
            // åˆå§‹æ‰‹ç‰Œï¼šå®Œå…¨éšæœº
            const shuffled = [...CARD_DECK].sort(() => 0.5 - Math.random());
            for(let i=0; i<4; i++) {
                playerHand.push(shuffled[i]);
                createCardDOM(shuffled[i], i);
            }
            nextCard = shuffled[4]; 
        }

        function createCardDOM(typeKey, index) {
            const unit = UNIT_TYPES[typeKey];
            const div = document.createElement('div');
            div.className = 'card w-20 h-28 rounded-xl border-2 relative cursor-pointer flex flex-col items-center select-none overflow-hidden group';
            div.onclick = () => selectCard(index);
            div.dataset.index = index;
            div.dataset.cost = unit.cost;

            div.innerHTML = `
                <div class="absolute top-0 left-0 w-full h-full bg-[url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0IiBoZWlnaHQ9IjQiPgo8cmVjdCB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjZmZmIiBmaWxsLW9wYWNpdHk9IjAuMDUiLz4KPC9zdmc+')] opacity-30"></div>
                
                <!-- è´¹ç”¨ -->
                <div class="absolute -top-1 -left-1 bg-gradient-to-br from-orange-500 to-red-600 rounded-br-lg w-7 h-7 flex items-center justify-center text-sm font-black text-white z-10 shadow-md border border-orange-400 pt-1 pl-1">${unit.cost}</div>
                
                <!-- å›¾æ ‡ -->
                <div class="h-16 w-full flex items-center justify-center text-4xl role-icon z-0 mt-3 transform group-hover:scale-110 transition-transform duration-200 drop-shadow-sm">
                    ${unit.icon}
                </div>
                
                <!-- ä¿¡æ¯ -->
                <div class="w-full flex-1 bg-[#2d1b0e]/90 p-1 z-10 flex flex-col justify-center border-t border-[#8d6e63]">
                    <div class="text-[10px] text-center font-bold text-amber-100 uppercase tracking-tight leading-none mb-0.5">${unit.name}</div>
                    <div class="text-[8px] text-center text-amber-400/80 font-mono">${unit.type}</div>
                </div>
            `;
            
            const container = document.getElementById('card-container');
            if (container.children[index]) container.replaceChild(div, container.children[index]);
            else container.appendChild(div);
        }

        function selectCard(index) {
            if (!gameActive) return;
            const cards = document.querySelectorAll('.card');
            
            if (selectedCardIdx === index) {
                selectedCardIdx = -1;
                cards[index].classList.remove('selected');
                hidePlacementGuide();
            } else {
                cards.forEach(c => c.classList.remove('selected'));
                selectedCardIdx = index;
                cards[index].classList.add('selected');
                showPlacementGuide();
            }
        }

        let placementMesh;
        function showPlacementGuide() {
            if (!placementMesh) {
                placementMesh = new THREE.Mesh(new THREE.PlaneGeometry(24, 13), materials.highlightValid);
                placementMesh.rotation.x = -Math.PI / 2;
                placementMesh.position.set(0, 0.2, 7.5); // åªå…è®¸åœ¨å·±æ–¹åŠåœº
                scene.add(placementMesh);
            }
            placementMesh.visible = true;
        }
        function hidePlacementGuide() { if(placementMesh) placementMesh.visible = false; }

        function onPointerDown(event) {
            if (!gameActive || selectedCardIdx === -1) return;
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children);

            for (let hit of intersects) {
                if (hit.object.name === 'ground' || hit.object === placementMesh) {
                    if (hit.point.z > 1) { // ç®€å•çš„åŒºåŸŸé™åˆ¶
                        attemptDeploy(hit.point.x, hit.point.z);
                    }
                    break;
                }
            }
        }

        function attemptDeploy(x, z) {
            const unitType = playerHand[selectedCardIdx];
            const cost = UNIT_TYPES[unitType].cost;

            if (elixir >= cost) {
                spawnUnit('blue', unitType, x, z);
                elixir -= cost;
                
                // å¾ªç¯å¡ç‰Œ
                const old = playerHand[selectedCardIdx];
                playerHand[selectedCardIdx] = nextCard;
                // éšæœºä¸‹ä¸€å¼ 
                nextCard = CARD_DECK[Math.floor(Math.random() * CARD_DECK.length)];
                createCardDOM(playerHand[selectedCardIdx], selectedCardIdx);
                
                selectedCardIdx = -1;
                hidePlacementGuide();
                document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
            } else {
                elElixirCount.classList.add('text-red-500', 'scale-125');
                setTimeout(()=>elElixirCount.classList.remove('text-red-500', 'scale-125'), 200);
            }
        }

        /**
         * ä¸»å¾ªç¯
         */
        function startGame() {
            document.getElementById('loading-screen').classList.add('hidden');
            gameActive = true;
            animate();
            setInterval(aiLoop, 2800); // AI æ€è€ƒé—´éš”
        }

        function endGame(result) {
            gameActive = false;
            document.getElementById('game-over-screen').classList.remove('hidden');
            const title = document.getElementById('result-title');
            title.innerText = result === 'win' ? "å¤§è·å…¨èƒœ!" : "æƒœè´¥...";
            title.className = result === 'win' ? "text-7xl font-black text-amber-400 mb-4 drop-shadow-2xl transform -rotate-6" : "text-7xl font-black text-gray-400 mb-4 drop-shadow-2xl";
            document.getElementById('result-crowns-blue').innerText = teamBlueCrowns;
            document.getElementById('result-crowns-red').innerText = teamRedCrowns;
        }

        function aiLoop() {
            if (!gameActive) return;
            // é•œåƒå¹³è¡¡ AIï¼šå®Œå…¨ä½¿ç”¨åŒæ ·çš„å¡æ± 
            if (Math.random() > 0.35) { 
                const keys = Object.keys(UNIT_TYPES);
                const type = keys[Math.floor(Math.random() * keys.length)];
                // AI éšæœºé€‰æ‹©ä¸€è·¯è¿›æ”»
                const x = Math.random() > 0.5 ? 5 : -5;
                // ç¨å¾®éšæœºåŒ–æ”¾ç½®ä½ç½®
                const z = -10 - Math.random() * 2;
                spawnUnit('red', type, x, z);
            }
        }

        function animate() {
            if (!gameActive) return;
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            gameTime -= dt;
            if (gameTime <= 0) {
                if (teamBlueCrowns > teamRedCrowns) endGame('win');
                else if (teamRedCrowns > teamBlueCrowns) endGame('lose');
                else endGame('win'); // å¹³å±€ç®—èµ¢
                return;
            }
            const m = Math.floor(gameTime / 60);
            const s = Math.floor(gameTime % 60);
            elTimer.innerText = `${m}:${s<10?'0'+s:s}`;

            if (elixir < CONFIG.ELIXIR_MAX) {
                elixir += (dt / CONFIG.ELIXIR_REGEN_RATE);
                if(elixir > CONFIG.ELIXIR_MAX) elixir = CONFIG.ELIXIR_MAX;
            }
            elElixirFill.style.width = `${(elixir / CONFIG.ELIXIR_MAX) * 100}%`;
            elElixirCount.innerText = Math.floor(elixir);

            document.querySelectorAll('.card').forEach(c => {
                if(parseInt(c.dataset.cost) > elixir) c.classList.add('disabled');
                else c.classList.remove('disabled');
            });

            textures.water.offset.y -= dt * 0.15;

            entities.forEach(e => e.update(dt));
            projectiles.forEach(p => p.update(dt));
            
            entities = entities.filter(e => !e.isDead);
            projectiles = projectiles.filter(p => p.active);

            particles.forEach((p, i) => {
                p.life -= dt;
                p.mesh.position.add(p.vel.clone().multiplyScalar(dt));
                p.mesh.rotation.x += dt*3;
                p.mesh.scale.multiplyScalar(0.9); 
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            });

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();

    </script>
</body>
</html>